Алгоритм

1.	Проверка корректности входных данных
	При получении на вход некорректных данных вызывается экстренный выход
	из программы с сообщением об ошибке. При рекуррентном вызове ошибка
	может возникнуть только в случае неправильно заданного исходного дерева.
	Тогда одно из входящих деревьев будет пустым.

2.	Проверка корней входных деревьев
	Так как корнем входного дерева могут быть либо операции вычисления, 
	либо операция чтения, возможны четыре варианта

						1		чтение		чтение
						2		чтение		операция
						3		операция	чтение
						4		операция	операция

						
Случай 1 (чтение-чтение)
	Создается переключатель для двух операций чтения 
		(дерево с корнем Flag и вершинами операциями чтения данных для каждого дерева).


Случай 2 (чтение-операция)
	Создается покрывающее дерево на основе входного, не состоящего из одной операции.
	Все операции чтения заменяются на переключатели. Переключатели настраиваются 
	следующим образом: данные определяются рекурсивно от корня к листьям. 
	
	Возможны три операции:
		•	Операция чтения данных — первый случай.
		•	Операция ‘+’ — вызывается две функции построения покрывающего дерева. 
			Первая для первого дерева и левой ветки второго дерева, вторая для дерева,
			состоящей из одной операции чтения данных, содержащую константу 0, 
			и правой ветки второго дерева.
		•	Операция ‘*’ — вызывается две функции построения покрывающего дерева. 
			Первая для первого дерева и левой ветки второго дерева, вторая для дерева, 
			состоящей из одной операции чтения данных, содержащую константу 0, 
			и правой ветки второго дерева.

Случай 3 (операция-чтение)
	Аналогичен случаю 2.

Случай 4 (операция-операция) 
	Рассматриваются два случая.
		4.1 Вершина покрывающего дерева — общая вершина первого и второго входных деревьев
		4.2 Вершина покрывающего дерева — вершина одного из входных деревьев

				Первый случай возникает, когда вершины первого и второго дерева совпадают (++ или **). 
				Второй — вершины не совпадают.

	Случай 4.1
		Вершина покрывающего дерева — общая вершина первого и второго входных деревьев
		Правое поддерево — покрывающее дерево для правых ветвей входных деревьев. Левое — аналогично.

	Случай 4.2
		Вершина покрывающего дерева — вершина одного из входных деревьев
		Рассматриваются четыре варианта: два с вершиной-операцией первого дерева,
		два — второго.
		Так как операции не обладают свойством коммутативности, для сохранения 
		достижимости вершин правое поддерево первого дерева должно располагаться 
		в правой ветви покрывающего дерева, левое — в левой. Второе дерево располагается
		полностью в одной из ветвей покрывающего дерева. Таким образом рассматриваются варианты:

			4.2.1
				Правое поддерево — покрывающее дерево для правой ветви первого дерева и второго дерева; 
				Левое поддерево — покрывающее дерево для левой ветви первого дерева и дерева, 
					состоящей из одной операции чтения данных, содержащую соответствующую константу.

			4.2.2
				Правое поддерево — покрывающее дерево для правой ветви первого дерева и дерева,
					состоящей из одной операции чтения данных, содержащую соответствующую константу; 
				Левое поддерево — покрывающее дерево для левой ветви первого дерева и второго дерева.

			4.2.3
				Правое поддерево — покрывающее дерево для правой ветви первого дерева и второго дерева;
				Левое поддерево — покрывающее дерево для левой ветви первого дерева и дерева,
					состоящей из одной операции чтения данных, содержащую соответствующую константу.

			4.2.4
				Правое поддерево — покрывающее дерево для правой ветви первого дерева и дерева,
					состоящей из одной операции чтения данных, содержащую соответствующую константу; 
				Левое поддерево — покрывающее дерево для левой ветви первого дерева и второго дерева.

Из всех вариантов выбирается наименьший и эти ветви становятся ветвями покрывающего дерева. Полученное покрывающее дерево возвращается как результат алгоритма.